import 'package:flutter_map/flutter_map.dart';
import 'package:immo_tools/services/dvf_api_service.dart';
import 'package:immo_tools/services/dvf_service.dart';

import 'package:latlong2/latlong.dart';

// ignore_for_file: avoid_print
/// Script de test d'int√©gration complet pour l'API DVF
/// Peut √™tre ex√©cut√© avec: dart test/dvf_integration_test.dart
void main() async {
  print('üöÄ Test d\'int√©gration complet de l\'API DVF\n');

  final dvfApiService = DvfApiService();
  final dvfService = DvfService();

  // Test d'int√©gration complet
  print('=== Test d\'int√©gration complet ===');
  await testFullIntegration(dvfApiService, dvfService);

  print('\n=== Test de donn√©es r√©elles ===');
  await testRealData(dvfApiService, dvfService);

  print('\n=== Test de validation des donn√©es ===');
  await testDataValidation(dvfApiService, dvfService);

  print('\n=== Test de gestion d\'erreurs ===');
  await testErrorHandling(dvfApiService, dvfService);

  print('\nüéâ Tests d\'int√©gration termin√©s!');
}

/// Test d'int√©gration complet
Future<void> testFullIntegration(
    DvfApiService dvfApiService, DvfService dvfService) async {
  try {
    print('üîç Test 1: R√©cup√©ration des parcelles');
    final parcels = await dvfApiService.getParcelles('75103');
    print('‚úÖ ${parcels.length} parcelles r√©cup√©r√©es');

    if (parcels.isNotEmpty) {
      final parcel = parcels.first;
      print(
          'üìä Premi√®re parcelle: ${parcel.id} (${parcel.section}${parcel.number})');

      print('\nüîç Test 2: R√©cup√©ration des donn√©es DVF pour cette parcelle');
      final dvfData = await dvfApiService.getDvfData(
        communeCode: parcel.communeCode,
        parcelCode: parcel.prefix + parcel.section,
        startDate: '2020-01-01',
        endDate: '2024-01-01',
      );
      print('‚úÖ ${dvfData.length} transactions DVF r√©cup√©r√©es');

      if (dvfData.isNotEmpty) {
        final transaction = dvfData.first;
        print('üìä Premi√®re transaction:');
        print('   - Date: ${transaction.txDate}');
        print('   - Prix: ${transaction.price}‚Ç¨');
        print(
            '   - Prix/m¬≤: ${transaction.squareMeterPrice.toStringAsFixed(2)}‚Ç¨');
        print('   - Surface: ${transaction.attributes.livingArea}m¬≤');
        print('   - Adresse: ${transaction.location.cityName}');

        print('\nüîç Test 3: Test du service DVF avec bounds');
        final bounds = LatLngBounds(
          LatLng(transaction.location.latitude - 0.001,
              transaction.location.longitude - 0.001),
          LatLng(transaction.location.latitude + 0.001,
              transaction.location.longitude + 0.001),
        );

        final boundsData = await dvfService.getData(
          bounds: bounds,
          minDate: DateTime(2020, 1, 1),
          maxDate: DateTime(2024, 1, 1),
        );
        print('‚úÖ ${boundsData.length} transactions r√©cup√©r√©es avec bounds');

        print('\nüîç Test 4: Test de disponibilit√© du service');
        final isAvailable = await dvfService.isAvailable();
        print('‚úÖ Service disponible: $isAvailable');

        print('\nüîç Test 5: Test de d√©tails de propri√©t√©');
        final details = await dvfService.getPropertyDetails(transaction.txId);
        if (details != null) {
          print('‚úÖ D√©tails r√©cup√©r√©s pour la propri√©t√© ${transaction.txId}');
        } else {
          print('‚ÑπÔ∏è Aucun d√©tail disponible pour cette propri√©t√©');
        }
      }
    }
  } catch (e) {
    print('‚ùå Erreur lors du test d\'int√©gration: $e');
  }
}

/// Test avec des donn√©es r√©elles
Future<void> testRealData(
    DvfApiService dvfApiService, DvfService dvfService) async {
  try {
    print('üîç Test avec des donn√©es r√©elles de Paris');

    // Test avec des communes parisiennes r√©elles
    final parisCommunes = [
      {'code': '75101', 'name': 'Paris 1er'},
      {'code': '75102', 'name': 'Paris 2e'},
      {'code': '75103', 'name': 'Paris 3e'},
      {'code': '75104', 'name': 'Paris 4e'},
      {'code': '75105', 'name': 'Paris 5e'},
    ];

    for (final commune in parisCommunes) {
      print('\nüìä Test avec ${commune['name']} (${commune['code']})');

      try {
        final parcels = await dvfApiService.getParcelles(commune['code']!);
        print('   - Parcelles: ${parcels.length}');

        if (parcels.isNotEmpty) {
          final parcel = parcels.first;
          final dvfData = await dvfApiService.getDvfData(
            communeCode: commune['code']!,
            parcelCode: parcel.number,
            startDate: '2023-01-01',
            endDate: '2024-01-01',
          );
          print('   - Transactions DVF: ${dvfData.length}');

          if (dvfData.isNotEmpty) {
            final transaction = dvfData.first;
            print(
                '   - Derni√®re transaction: ${transaction.txDate} - ${transaction.price}‚Ç¨');
          }
        }
      } catch (e) {
        print('   ‚ùå Erreur pour ${commune['name']}: $e');
      }
    }
  } catch (e) {
    print('‚ùå Erreur lors du test avec donn√©es r√©elles: $e');
  }
}

/// Test de validation des donn√©es
Future<void> testDataValidation(
    DvfApiService dvfApiService, DvfService dvfService) async {
  try {
    print('üîç Test de validation des donn√©es');

    final dvfData = await dvfApiService.getDvfData(
      communeCode: '75101',
      parcelCode: '0001',
      startDate: '2020-01-01',
      endDate: '2024-01-01',
    );

    print('‚úÖ ${dvfData.length} transactions r√©cup√©r√©es pour validation');

    if (dvfData.isNotEmpty) {
      int validTransactions = 0;
      int invalidTransactions = 0;

      for (final transaction in dvfData) {
        bool isValid = true;
        final issues = <String>[];

        // Validation des champs obligatoires
        if (transaction.txDate.isEmpty) {
          isValid = false;
          issues.add('Date manquante');
        }

        if (transaction.price <= 0) {
          isValid = false;
          issues.add('Prix invalide');
        }

        if (transaction.location.latitude == 0 &&
            transaction.location.longitude == 0) {
          isValid = false;
          issues.add('Coordonn√©es invalides');
        }

        if (transaction.location.latitude == 0 &&
            transaction.location.longitude == 0) {
          isValid = false;
          issues.add('Coordonn√©es nulles');
        }

        if (transaction.attributes.livingArea != null &&
            transaction.attributes.livingArea! <= 0) {
          isValid = false;
          issues.add('Surface invalide');
        }

        if (transaction.squareMeterPrice < 0) {
          isValid = false;
          issues.add('Prix au m¬≤ invalide');
        }

        if (isValid) {
          validTransactions++;
        } else {
          invalidTransactions++;
          if (invalidTransactions <= 5) {
            print('‚ùå Transaction invalide: ${issues.join(', ')}');
          }
        }
      }

      print('üìä R√©sultats de validation:');
      print('   - Transactions valides: $validTransactions');
      print('   - Transactions invalides: $invalidTransactions');
      print(
          '   - Taux de validit√©: ${(validTransactions / dvfData.length * 100).toStringAsFixed(1)}%');

      if (invalidTransactions > 0) {
        print('‚ö†Ô∏è $invalidTransactions transactions invalides d√©tect√©es');
      } else {
        print('‚úÖ Toutes les transactions sont valides');
      }
    }
  } catch (e) {
    print('‚ùå Erreur lors de la validation des donn√©es: $e');
  }
}

/// Test de gestion d'erreurs
Future<void> testErrorHandling(
    DvfApiService dvfApiService, DvfService dvfService) async {
  try {
    print('üîç Test de gestion d\'erreurs');

    // Test avec des param√®tres invalides
    print('\nüìä Test avec code commune invalide');
    try {
      await dvfApiService.getDvfData(
        communeCode: 'invalid_code',
        parcelCode: '0001',
      );
      print('‚ö†Ô∏è Aucune erreur avec code invalide');
    } catch (e) {
      print('‚úÖ Erreur attendue avec code invalide: $e');
    }

    print('\nüìä Test avec parcelle invalide');
    try {
      await dvfApiService.getDvfData(
        communeCode: '75101',
        parcelCode: 'invalid_parcel',
      );
      print('‚ö†Ô∏è Aucune erreur avec parcelle invalide');
    } catch (e) {
      print('‚úÖ Erreur attendue avec parcelle invalide: $e');
    }

    print('\nüìä Test avec dates invalides');
    try {
      final bounds = LatLngBounds(
        const LatLng(48.8566, 2.3522),
        const LatLng(48.8606, 2.3562),
      );

      await dvfService.getData(
        bounds: bounds,
        minDate: DateTime(2025, 1, 1), // Date future
        maxDate: DateTime(2020, 1, 1), // Date pass√©e
      );
      print('‚ö†Ô∏è Aucune erreur avec dates invalides');
    } catch (e) {
      print('‚úÖ Erreur attendue avec dates invalides: $e');
    }

    print('\nüìä Test avec bounds invalides');
    try {
      final invalidBounds = LatLngBounds(
        const LatLng(48.8606, 2.3562), // Nord-Est
        const LatLng(48.8566, 2.3522), // Sud-Ouest (invers√©)
      );

      await dvfService.getData(bounds: invalidBounds);
      print('‚ö†Ô∏è Aucune erreur avec bounds invalides');
    } catch (e) {
      print('‚úÖ Erreur attendue avec bounds invalides: $e');
    }

    print('\nüìä Test avec filtres invalides');
    try {
      final bounds = LatLngBounds(
        const LatLng(48.8566, 2.3522),
        const LatLng(48.8606, 2.3562),
      );

      await dvfService.getData(
        bounds: bounds,
        minPrice: 1000000,
        maxPrice: 100000, // Prix min > prix max
      );
      print('‚ö†Ô∏è Aucune erreur avec filtres invalides');
    } catch (e) {
      print('‚úÖ Erreur attendue avec filtres invalides: $e');
    }
  } catch (e) {
    print('‚ùå Erreur lors du test de gestion d\'erreurs: $e');
  }
}
